<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Android: please finally disrank and abandon findViewById() and friends TL;DR Data binding and view model patterns are all in favor instead.  It looks like even though Android’s data binding has been a">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2018/04/18/Android-asd/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Android: please finally disrank and abandon findViewById() and friends TL;DR Data binding and view model patterns are all in favor instead.  It looks like even though Android’s data binding has been a">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-04-18T15:03:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="Android: please finally disrank and abandon findViewById() and friends TL;DR Data binding and view model patterns are all in favor instead.  It looks like even though Android’s data binding has been a">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Android-asd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/18/Android-asd/" class="article-date">
  <time datetime="2018-04-18T15:02:19.000Z" itemprop="datePublished">2018-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-please-finally-disrank-and-abandon-findViewById-and-friends"><a href="#Android-please-finally-disrank-and-abandon-findViewById-and-friends" class="headerlink" title="Android: please finally disrank and abandon findViewById() and friends"></a>Android: please finally disrank and abandon <code>findViewById()</code> and friends</h1><blockquote>
<p>TL;DR Data binding and view model patterns are all in favor instead.</p>
</blockquote>
<p>It looks like even though Android’s data binding has been around for quite a lot of time, and the community has been quite hands-on with MVP / MVVM families of patters, people still tend to use <code>findViewById()</code> – it is creeping through good libraries and articles.</p>
<p>And (funny), when Kotlin became wide-spread, there appeared articles which suggested dealing with <code>findViewById()</code> in Kotlin way, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val nameTextView by lazy &#123; view!!.findViewById&lt;TextView&gt;(R.id.nameTextView) &#125;</span><br></pre></td></tr></table></figure>
<p>or by using delegates</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val stateTextView: TextView by findView(this, R.id.stateTextView)</span><br></pre></td></tr></table></figure>
<p>There is Also</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val details: TextView? by bindOptionalView(R.id.details)</span><br></pre></td></tr></table></figure>
<p>from KotterKnife</p>
<p>Even Kotlin Android Extensions, being a good library, take not an ideal direction:<a href="https://kotlinlang.org/docs/tutorials/android-plugin.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/tutorials/android-plugin.html</a><br>Generate code (which takes time).</p>
<p>Anko: <a href="https://www.kotlindevelopment.com/why-anko-layouts-dsl-better-xml/" target="_blank" rel="noopener">https://www.kotlindevelopment.com/why-anko-layouts-dsl-better-xml/</a><br>Not an option, mixing code and layout</p>
<p>I’ll explain why it’s not an optimal way, and how to become more efficient.</p>
<p>Disadvantages:</p>
<h3 id="1-Too-much-typing"><a href="#1-Too-much-typing" class="headerlink" title="1. Too much typing"></a>1. Too much typing</h3><p>You need to type IDs two times, in view and in presenter.</p>
<h3 id="2-Coupling-between-view-and-code"><a href="#2-Coupling-between-view-and-code" class="headerlink" title="2. Coupling between view and code"></a>2. Coupling between view and code</h3><p>Field implementaion might change: toggle button to checkbox.</p>
<p>Say you replaced <code>RelativeLayout</code> with <code>CoordinatorLayout</code>, now you need to make corresponding changes in code as well.</p>
<p>Say you changed color for checkmark.</p>
<p>Say you put a field in a container and want to control visibility by container, and not by field.</p>
<h3 id="Wastes-build-cycles-when-view-ID-changes-in-view-layout"><a href="#Wastes-build-cycles-when-view-ID-changes-in-view-layout" class="headerlink" title="Wastes build cycles when view ID changes in view layout"></a>Wastes build cycles when view ID changes in view layout</h3><p>View IDs in view layout must match those in code. How many times did you find yourself coming up with a better name for a view ID (and maybe also renaming some others, to keep naming consistent) and then rebuilding the app so that new IDs show up in code? And even in mid-size app that would be a lengthy cycle.</p>
<p>Say you’re a smart one and just type new ID w/o rebuilding, but how many minutes can you keep up w/o IntelliSense if writing code blindly?</p>
<h3 id="3-Wasting-build-time-to-generate-R-java"><a href="#3-Wasting-build-time-to-generate-R-java" class="headerlink" title="3. Wasting build time to generate R.java?"></a>3. Wasting build time to generate <code>R.java</code>?</h3><p>That might sound… but data binding proc can take more time.</p>
<h3 id="Abuse-of-reactive-approach"><a href="#Abuse-of-reactive-approach" class="headerlink" title="Abuse of reactive approach"></a>Abuse of reactive approach</h3><p>Reactive UI is almost a de-facto standard (will skip explanation, there are many good articles proving that), and <code>findViewById()</code> gets in the way of that:<br>with Reactive, we should say: ok, view, here are some streams (<code>Subject</code>s), publish to those when user interaction happens. On the other side, you gotta listen to some of <code>Observable</code>s and update yourself when we push new data to those.</p>
<p>But with <code>findViewById()</code>, instead of trusting view with its responsibility (style itself, react on data changes, propagate user input), we reach out to it and then shake and harass it by getting through its internals: e.g., calling <code>setText()</code>, <code>setOnClickListener()</code>, and (God save you) <code>setLayoutDimensionsTralala()</code>.</p>
<h3 id="Breach-of-encapsulation-Exposes-view-implementation"><a href="#Breach-of-encapsulation-Exposes-view-implementation" class="headerlink" title="Breach of encapsulation / Exposes view implementation"></a>Breach of encapsulation / Exposes view implementation</h3><p>That relates to the previous point: instead of allowing view to do its job on its own, we make our app aware of view’s internal specifics.</p>
<p>Why should we know how to set view’s style, margins, paddings, etc.?<br>Why should we know even how to set view’s text?<br>Why should we know structure and naming of view event handlers?</p>
<p>Again, we should flip that and let the view be plugged in (as opposed to be controlled).</p>
<h3 id="Coupling-with-Android-framework"><a href="#Coupling-with-Android-framework" class="headerlink" title="Coupling with Android framework"></a>Coupling with Android framework</h3><p>Any framework is an implementation detail (refer to Clean Architecture), so whenever we developers can, we should stay decoupled from it.</p>
<p>Remember: framework is an entity outside boundaries of application logic.</p>
<p>Also, in theory, we should be able to swap one framework with another.<br>Say I want a mobile web application: screen layout is almost the same, presentation logic is the same. Why can’t I port my code and compile it for web target? (Especially given that Kotlin compiles to JavaScript!)</p>
<h3 id="Easier-testing"><a href="#Easier-testing" class="headerlink" title="Easier testing"></a>Easier testing</h3><p>instrumentation tests (on devices / emulators) are freaking slow. Even though you use Robolectic to test on JVM, it requires a lot of ceremony to spin up activities and views.</p>
<p>When using ViewModel, you can test against it, not against views.<br>That shortens your TDD cycle a lot (you should do TDD; slow build and test times is also probably the main reason why TDD or just testing is abandoned for Android).</p>
<p>Testing against ViewModel as opposed to real views on screen (using Espresso, for example) are not mutually exclusive, you can still have your Espresso tests (and probably, you should), but key takeaway here is that you can have less (even much less) UI tests, because unit tests (those which test against ViewModel) would cover most of the cases.</p>
<p>Of course, there is always chance that somebody on team would not wire ViewModel to view 100% correct, but you can cover that with much fewer exploratory tests.</p>
<p>Maintaining and running UI tests is another (long and sometimes painful) story for a separate blog post.</p>
<p>So presenter dev cycle could look like:</p>
<ul>
<li>create a test (Spek) file for presenter</li>
<li>write a non-compiling test so its assertion verifies against ViewModel</li>
<li>create ViewModel class, add corresponding Field</li>
<li>implement functionality in presenter so that test passes</li>
</ul>
<p>Thus:</p>
<ul>
<li>you would be growing contract between view and presenter, step-by-step</li>
<li>your design will be driven by TDD, which mean it would be sufficient and clear<br>-</li>
</ul>
<p>Recap:</p>
<h5 id="We-use-view-ViewModel-to-establish-clear-contract-between-View-and-presenters"><a href="#We-use-view-ViewModel-to-establish-clear-contract-between-View-and-presenters" class="headerlink" title="We use view ViewModel to establish clear contract between View and presenters"></a>We use view ViewModel to establish clear contract between View and presenters</h5><h5 id="There-is-a-boundary-between-Presenter-and-View-and-ViewModel-instance-is-an-embodiement-of-contract-transferred-across-it"><a href="#There-is-a-boundary-between-Presenter-and-View-and-ViewModel-instance-is-an-embodiement-of-contract-transferred-across-it" class="headerlink" title="There is a boundary between Presenter and View, and ViewModel instance is an embodiement of contract transferred across it"></a>There is a boundary between Presenter and View, and ViewModel instance is an embodiement of contract transferred across it</h5><h5 id="We-can-change-view-implementation-and-ultimately-even-reuse-ViewModel-and-Presenter-for-different-platforms-since-Kotlin-is-heading-that-way"><a href="#We-can-change-view-implementation-and-ultimately-even-reuse-ViewModel-and-Presenter-for-different-platforms-since-Kotlin-is-heading-that-way" class="headerlink" title="We can change view implementation and (ultimately) even reuse ViewModel and Presenter for different platforms (since Kotlin is heading that way)"></a>We can change view implementation and (ultimately) even reuse ViewModel and Presenter for different platforms (since Kotlin is heading that way)</h5><h5 id="View-layout-is-decoupled-from-which-and-how-data-is-shown-on-screen"><a href="#View-layout-is-decoupled-from-which-and-how-data-is-shown-on-screen" class="headerlink" title="View layout is decoupled from which and how data is shown on screen"></a>View layout is decoupled from which and how data is shown on screen</h5><h5 id="Tests-do-not-require-Android-instrumentation-fast"><a href="#Tests-do-not-require-Android-instrumentation-fast" class="headerlink" title="Tests do not require Android instrumentation = fast"></a>Tests do not require Android instrumentation = fast</h5><h5 id="Dependency-inversion-principle-is-kept-view-is-dependent-on-view-model-so-that-dependency-points-inwards-compare-presenter-depends-on-view-type-dependency-points-outwards"><a href="#Dependency-inversion-principle-is-kept-view-is-dependent-on-view-model-so-that-dependency-points-inwards-compare-presenter-depends-on-view-type-dependency-points-outwards" class="headerlink" title="Dependency inversion principle is kept: view is dependent on view model, so that dependency points inwards; compare: presenter depends on view type, dependency points outwards"></a>Dependency inversion principle is kept: view is dependent on view model, so that dependency points inwards; compare: presenter depends on view type, dependency points outwards</h5><h5 id="View-implementaion-changes"><a href="#View-implementaion-changes" class="headerlink" title="View implementaion changes"></a>View implementaion changes</h5><h5 id="Decoupling-from-Android-framework-shortens-your-TDD-cycle-since-during-those-cycles-Android-framework-is-not-compiled"><a href="#Decoupling-from-Android-framework-shortens-your-TDD-cycle-since-during-those-cycles-Android-framework-is-not-compiled" class="headerlink" title="Decoupling from Android framework shortens your TDD cycle since during those cycles Android framework is not compiled"></a>Decoupling from Android framework shortens your TDD cycle since during those cycles Android framework is not compiled</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/18/Android-asd/" data-id="cjg588ibp0000mss434jtb2l6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/04/18/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/18/Android-asd/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/04/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>